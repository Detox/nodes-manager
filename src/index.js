// Generated by LiveScript 1.5.0
/**
 * @package Detox nodes manager
 * @author  Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @license 0BSD
 */
(function(){
  var DEFAULT_TIMEOUTS;
  DEFAULT_TIMEOUTS = {
    'STALE_AWARE_OF_NODE_TIMEOUT': 5 * 60
  };
  function Wrapper(detoxUtils, asyncEventer){
    var ArrayMap, ArraySet;
    ArrayMap = detoxUtils['ArrayMap'];
    ArraySet = detoxUtils['ArraySet'];
    /**
     * @constructor
     *
     * @param {!Array<string>}			bootstrap_nodes			Array of strings in format `node_id:address:port`
     * @param {!Array<string>}			aware_of_nodes_limit	How many aware of nodes should be kept in memory
     * @param {!Object<string, number>}	timeouts				Various timeouts and intervals used internally
     *
     * @return {!Manager}
     */
    function Manager(bootstrap_nodes, aware_of_nodes_limit, timeouts){
      var this$ = this;
      aware_of_nodes_limit == null && (aware_of_nodes_limit = 1000);
      timeouts == null && (timeouts = {});
      if (!(this instanceof Manager)) {
        return new Manager(bootstrap_nodes, aware_of_nodes_limit, timeouts);
      }
      asyncEventer.call(this);
      this._timeouts = Object.assign({}, DEFAULT_TIMEOUTS, timeouts);
      this._aware_of_nodes_limit = aware_of_nodes_limit;
      this._bootstrap_nodes = ArrayMap(bootstrap_nodes);
      this._bootstrap_nodes_ids = ArrayMap();
      this._used_first_nodes = ArraySet();
      this._connected_nodes = ArraySet();
      this._peers = ArraySet();
      this._aware_of_nodes = ArrayMap();
      this._cleanup_interval = intervalSet(this._timeouts['STALE_AWARE_OF_NODE_TIMEOUT'], function(){
        var super_stale_older_than;
        super_stale_older_than = +new Date - this$._timeouts['STALE_AWARE_OF_NODE_TIMEOUT'] * 2 * 1000;
        this$._aware_of_nodes.forEach(function(date, node_id){
          if (date < super_stale_older_than) {
            this$._aware_of_nodes['delete'](node_id);
          }
        });
      });
    }
    Manager.prototype = {
      /**
       * @param {!Uint8Array}	node_id
       * @param {string}		bootstrap_node
       */
      'add_bootstrap_node': function(node_id, bootstrap_node){
        var bootstrap_node_id;
        bootstrap_node_id = hex2array(bootstrap_node.split(':')[0]);
        this._bootstrap_nodes.set(bootstrap_node_id, bootstrap_node);
        this._bootstrap_nodes_ids.set(node_id, bootstrap_node_id);
      }
      /**
       * @return {!Array<string>}
       */,
      'get_bootstrap_nodes': function(){
        return Array.from(this._bootstrap_nodes.values());
      }
      /**
       * @param {!Array<!Uint8Array>} exclude_nodes
       *
       * @return {!Array<!Uint8Array>}
       */,
      'get_candidates_for_disconnection': function(exclude_nodes){
        var candidates, this$ = this;
        exclude_nodes = ArraySet(exclude_nodes);
        candidates = [];
        this._connected_nodes.forEach(function(node_id){
          if (!(exclude_nodes.has(node_id), this$._used_first_nodes.has(node_id) || this$._peers.has(node_id))) {
            candidates.push(node_id);
          }
        });
        return candidates;
      }
      /**
       * @param {!Uint8Array} node_id
       */,
      'add_connected_node': function(node_id){
        this._connected_nodes.add(node_id);
        this._aware_of_nodes['delete'](node_id);
        this['fire']('connected_nodes_count', this._connected_nodes.size);
        this['fire']('aware_of_nodes_count', this._aware_of_nodes.size);
      }
      /**
       * @param {!Uint8Array} node_id
       *
       * @return {boolean}
       */,
      'has_connected_node': function(node_id){
        return this._connected_nodes.has(peer_peer_id);
      }
      /**
       * @param {!Uint8Array} node_id
       */,
      'del_connected_node': function(node_id){
        this._connected_nodes['delete'](node_id);
        this._peers['delete'](node_id);
        this['fire']('connected_nodes_count', this._connected_nodes.size);
      }
      /**
       * @param {!Uint8Array}			peer_id
       * @param {!Array<!Uint8Array>}	peer_peers
       */,
      'set_peer': function(peer_id, peer_peers){
        var i$, len$, peer_peer_id;
        this._peers.add(peer_id);
        for (i$ = 0, len$ = peer_peers.length; i$ < len$; ++i$) {
          peer_peer_id = peer_peers[i$];
          if (!this._connected_nodes.has(peer_peer_id)) {
            this._aware_of_nodes.set(peer_peer_id, +new Date);
          }
        }
      }
      /**
       * @param {!Uint8Array}			node_id	Source node ID
       * @param {!Array<!Uint8Array>}	nodes	IDs of nodes `node_id` is aware of
       */,
      'set_aware_of_nodes': function(node_id, nodes){}
      /**
       * @return {!Array<!Uint8Array>}
       */,
      'get_aware_of_nodes': function(){}
      /**
       * @return {boolean}
       */,
      'more_aware_of_nodes_needed': function(){
        return Boolean(this._aware_of_nodes.size < this._aware_of_nodes_limit || this._get_stale_aware_of_nodes(true).length);
      }
      /**
       * @param {boolean=} early_exit Will return single node if present, used to check if stale nodes are present at all
       *
       * @return {!Array<!Uint8Array>}
       */,
      _get_stale_aware_of_nodes: function(early_exit){
        var stale_aware_of_nodes, stale_older_than, exited;
        early_exit == null && (early_exit = false);
        stale_aware_of_nodes = [];
        stale_older_than = +new Date - this._timeouts['STALE_AWARE_OF_NODE_TIMEOUT'] * 1000;
        exited = false;
        this._aware_of_nodes.forEach(function(date, node_id){
          if (!exited && date < stale_older_than) {
            stale_aware_of_nodes.push(node_id);
            if (early_exit && !exited) {
              exited = true;
            }
          }
        });
        return stale_aware_of_nodes;
      }
      /**
       * @param {number}	number_of_nodes
       *
       * @return {Array<!Uint8Array>} `null` if there was not enough nodes
       */,
      'get_nodes_for_routing_path': function(number_of_nodes){
        var nodes;
        nodes = [];
        if (!nodes.length) {
          return null;
        }
        this._used_first_nodes.add(nodes[0]);
        return nodes;
      }
      /**
       * @param {!Uint8Array} node_id
       */,
      'del_first_node_in_routing_path': function(node_id){
        this._used_first_nodes['delete'](first_node);
      },
      'destroy': function(){
        if (this._destroyed) {
          return;
        }
        this._destroyed = true;
        clearInterval(this._cleanup_interval);
      }
    };
    Manager.prototype = Object.assign(Object.create(asyncEventer.prototype), Manager.prototype);
    Object.defineProperty(Manager.prototype, 'constructor', {
      value: Manager
    });
    return Manager;
  }
  if (typeof define === 'function' && define['amd']) {
    define(['@detox/utils', 'async-eventer'], Wrapper);
  } else if (typeof exports === 'object') {
    module.exports = Wrapper(require('@detox/utils'), require('async-eventer'));
  } else {
    this['detox_nodes_manager'] = Wrapper(this['detox_utils'], this['async_eventer']);
  }
}).call(this);
