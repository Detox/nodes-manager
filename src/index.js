// Generated by LiveScript 1.5.0
/**
 * @package Detox nodes manager
 * @author  Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @license 0BSD
 */
(function(){
  function Wrapper(detoxUtils, asyncEventer){
    var ArrayMap, ArraySet;
    ArrayMap = detoxUtils['ArrayMap'];
    ArraySet = detoxUtils['ArraySet'];
    /**
     * @constructor
     *
     * @return {!Manager}
     */
    function Manager(){
      if (!(this instanceof Manager)) {
        return new Manager();
      }
      asyncEventer.call(this);
      this._bootstrap_nodes = ArrayMap();
      this._used_first_nodes = ArraySet();
      this._connected_nodes = ArraySet();
      this._peers = ArraySet();
      this._aware_of_nodes = ArrayMap();
    }
    Manager.prototype = {
      /**
       * @param {string} bootstrap_node
       */
      'add_bootstrap_node': function(bootstrap_node){
        var bootstrap_node_id;
        bootstrap_node_id = hex2array(bootstrap_node.split(':')[0]);
        this._bootstrap_nodes_ids.set(bootstrap_node_id, bootstrap_node);
      }
      /**
       * @param {!Array<!Uint8Array>} exclude_nodes
       *
       * @return {!Array<!Uint8Array>}
       */,
      'get_candidates_for_disconnection': function(exclude_nodes){
        var candidates, this$ = this;
        exclude_nodes = ArraySet(exclude_nodes);
        candidates = [];
        this._connected_nodes.forEach(function(node_id){
          if (!(exclude_nodes.has(node_id), this$._used_first_nodes.has(node_id) || this$._peers.has(node_id))) {
            candidates.push(node_id);
          }
        });
        return candidates;
      }
      /**
       * @param {!Uint8Array} node_id
       */,
      'add_connected_node': function(node_id){
        this._connected_nodes.add(node_id);
        this._aware_of_nodes['delete'](node_id);
        this['fire']('connected_nodes_count', this._connected_nodes.size);
        this['fire']('aware_of_nodes_count', this._aware_of_nodes.size);
      }
      /**
       * @param {!Uint8Array} node_id
       *
       * @return {boolean}
       */,
      'has_connected_node': function(node_id){
        return this._connected_nodes.has(peer_peer_id);
      }
      /**
       * @param {!Uint8Array} node_id
       */,
      'del_connected_node': function(node_id){
        this._connected_nodes['delete'](node_id);
        this._peers['delete'](node_id);
        this['fire']('connected_nodes_count', this._connected_nodes.size);
      }
      /**
       * @param {!Uint8Array}			peer_id
       * @param {!Array<!Uint8Array>}	peer_peers
       */,
      'add_peer': function(peer_id, peer_peers){
        var i$, len$, peer_peer_id;
        this._peers.add(peer_id);
        for (i$ = 0, len$ = peer_peers.length; i$ < len$; ++i$) {
          peer_peer_id = peer_peers[i$];
          if (!this._connected_nodes.has(peer_peer_id)) {
            this._aware_of_nodes.set(peer_peer_id, +new Date);
          }
        }
      }
      /**
       * @param {!Uint8Array}			node_id	Source node ID
       * @param {!Array<!Uint8Array>}	nodes	IDs of nodes `node_id` is aware of
       */,
      'set_aware_of_nodes': function(node_id, nodes){}
      /**
       * @return {boolean}
       */,
      'has_stale_aware_of_nodes': function(){}
      /**
       * @return {!Array<!Uint8Array>}
       */,
      'get_stale_aware_of_nodes': function(){}
      /**
       * @param {number}	number_of_nodes
       *
       * @return {Array<!Uint8Array>} `null` if there was not enough nodes
       */,
      'get_nodes_for_routing_path': function(number_of_nodes){},
      'del_first_node_in_routing_path': function(node_id){
        this._used_first_nodes['delete'](first_node);
      },
      'destroy': function(){
        if (this._destroyed) {
          return;
        }
        this._destroyed = true;
      }
    };
    Manager.prototype = Object.assign(Object.create(asyncEventer.prototype), Manager.prototype);
    Object.defineProperty(Manager.prototype, 'constructor', {
      value: Manager
    });
    return {
      'Manager': Manager
    };
  }
  if (typeof define === 'function' && define['amd']) {
    define(['@detox/utils', 'async-eventer'], Wrapper);
  } else if (typeof exports === 'object') {
    module.exports = Wrapper(require('@detox/utils'), require('async-eventer'));
  } else {
    this['detox_core'] = Wrapper(this['detox_utils'], this['async_eventer']);
  }
}).call(this);
