// Generated by LiveScript 1.5.0
/**
 * @package Detox nodes manager
 * @author  Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @license 0BSD
 */
(function(){
  var STALE_AWARE_OF_NODE_TIMEOUT;
  STALE_AWARE_OF_NODE_TIMEOUT = 5 * 60;
  function Wrapper(detoxUtils, asyncEventer){
    var hex2array, pull_random_item_from_array, are_arrays_equal, intervalSet, ArrayMap, ArraySet;
    hex2array = detoxUtils['hex2array'];
    pull_random_item_from_array = detoxUtils['pull_random_item_from_array'];
    are_arrays_equal = detoxUtils['are_arrays_equal'];
    intervalSet = detoxUtils['intervalSet'];
    ArrayMap = detoxUtils['ArrayMap'];
    ArraySet = detoxUtils['ArraySet'];
    /**
     * @constructor
     *
     * @param {!Array<string>}	bootstrap_nodes				Array of strings in format `node_id:address:port`
     * @param {!Array<string>}	aware_of_nodes_limit		How many aware of nodes should be kept in memory
     * @param {number}			stale_aware_of_node_timeout
     *
     * @return {!Manager}
     */
    function Manager(bootstrap_nodes, aware_of_nodes_limit, stale_aware_of_node_timeout){
      var i$, len$, bootstrap_node, bootstrap_node_id, this$ = this;
      aware_of_nodes_limit == null && (aware_of_nodes_limit = 1000);
      stale_aware_of_node_timeout == null && (stale_aware_of_node_timeout = STALE_AWARE_OF_NODE_TIMEOUT);
      if (!(this instanceof Manager)) {
        return new Manager(bootstrap_nodes, aware_of_nodes_limit, stale_aware_of_node_timeout);
      }
      asyncEventer.call(this);
      this._aware_of_nodes_limit = aware_of_nodes_limit;
      this._stale_aware_of_node_timeout = stale_aware_of_node_timeout;
      this._bootstrap_nodes = ArrayMap();
      for (i$ = 0, len$ = bootstrap_nodes.length; i$ < len$; ++i$) {
        bootstrap_node = bootstrap_nodes[i$];
        bootstrap_node_id = hex2array(bootstrap_node.split(':')[0]);
        this._bootstrap_nodes.set(bootstrap_node_id, bootstrap_node);
      }
      this._bootstrap_nodes_ids = ArrayMap();
      this._used_first_nodes = ArraySet();
      this._connected_nodes = ArraySet();
      this._peers = ArrayMap();
      this._aware_of_nodes = ArrayMap();
      this._cleanup_interval = intervalSet(this._stale_aware_of_node_timeout, function(){
        var super_stale_older_than;
        super_stale_older_than = +new Date - this$._stale_aware_of_node_timeout * 2 * 1000;
        this$._aware_of_nodes.forEach(function(date, node_id){
          if (date < super_stale_older_than) {
            this$._aware_of_nodes['delete'](node_id);
          }
        });
      });
    }
    Manager.prototype = {
      /**
       * @param {!Uint8Array}	node_id
       * @param {string}		bootstrap_node
       */
      'add_bootstrap_node': function(node_id, bootstrap_node){
        var bootstrap_node_id;
        bootstrap_node_id = hex2array(bootstrap_node.split(':')[0]);
        this._bootstrap_nodes.set(bootstrap_node_id, bootstrap_node);
        this._bootstrap_nodes_ids.set(node_id, bootstrap_node_id);
      }
      /**
       * @return {!Array<string>}
       */,
      'get_bootstrap_nodes': function(){
        return Array.from(this._bootstrap_nodes.values());
      }
      /**
       * @param {!Array<!Uint8Array>} exclude_nodes
       *
       * @return {!Array<!Uint8Array>}
       */,
      'get_candidates_for_disconnection': function(exclude_nodes){
        var candidates, this$ = this;
        exclude_nodes = ArraySet(exclude_nodes);
        candidates = [];
        this._connected_nodes.forEach(function(node_id){
          if (!(exclude_nodes.has(node_id), this$._used_first_nodes.has(node_id) || this$._peers.has(node_id))) {
            candidates.push(node_id);
          }
        });
        return candidates;
      }
      /**
       * @param {!Uint8Array} node_id
       */,
      'add_connected_node': function(node_id){
        this._connected_nodes.add(node_id);
        this._aware_of_nodes['delete'](node_id);
        this['fire']('connected_nodes_count', this._connected_nodes.size);
        this['fire']('aware_of_nodes_count', this._aware_of_nodes.size);
      }
      /**
       * Get some random nodes from already connected nodes
       *
       * @param {number}	up_to_number_of_nodes
       *
       * @return {Array<!Uint8Array>} `null` if there is no nodes to return
       */,
      'get_random_connected_nodes': function(up_to_number_of_nodes){
        return this._get_random_connected_nodes(up_to_number_of_nodes);
      }
      /**
       * Get some random nodes from already connected nodes
       *
       * @param {number=}					up_to_number_of_nodes
       * @param {!Array<!Uint8Array>=}	exclude_nodes
       *
       * @return {Array<!Uint8Array>} `null` if there is no nodes to return
       */,
      _get_random_connected_nodes: function(up_to_number_of_nodes, exclude_nodes){
        var connected_nodes, exclude_nodes_set, i$, i, results$ = [];
        up_to_number_of_nodes == null && (up_to_number_of_nodes = 1);
        exclude_nodes == null && (exclude_nodes = []);
        if (!this._connected_nodes.size) {
          return null;
        }
        connected_nodes = Array.from(this._connected_nodes.values());
        exclude_nodes_set = ArraySet(exclude_nodes.concat(Array.from(this._bootstrap_nodes_ids.keys())));
        connected_nodes = connected_nodes.filter(function(node){
          return !exclude_nodes_set.has(node);
        });
        if (!connected_nodes.length) {
          return null;
        }
        for (i$ = 0; i$ < up_to_number_of_nodes; ++i$) {
          i = i$;
          if (connected_nodes.length) {
            results$.push(pull_random_item_from_array(connected_nodes));
          }
        }
        return results$;
      }
      /**
       * @param {!Uint8Array} node_id
       *
       * @return {boolean}
       */,
      'has_connected_node': function(node_id){
        return this._connected_nodes.has(node_id);
      }
      /**
       * @param {!Uint8Array} node_id
       */,
      'del_connected_node': function(node_id){
        this._connected_nodes['delete'](node_id);
        this._peers['delete'](node_id);
        this['fire']('connected_nodes_count', this._connected_nodes.size);
      }
      /**
       * @param {!Uint8Array}			peer_id
       * @param {!Array<!Uint8Array>}	peer_peers
       */,
      'set_peer': function(peer_id, peer_peers){
        this._peers.set(peer_id, ArraySet(peer_peers));
      }
      /**
       * @param {!Uint8Array}			peer_id	Source node ID
       * @param {!Array<!Uint8Array>}	nodes	IDs of nodes `peer_id` is aware of
       */,
      'set_aware_of_nodes': function(peer_id, nodes){
        var peer_peers, i$, len$, new_node_id, stale_aware_of_nodes, stale_node_to_remove;
        peer_peers = this._peers.get(peer_id);
        for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
          new_node_id = nodes[i$];
          if (peer_peers && peer_peers.has(new_node_id)) {
            this['fire']('peer_warning', peer_id);
            return;
          }
        }
        stale_aware_of_nodes = this._get_stale_aware_of_nodes();
        for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
          new_node_id = nodes[i$];
          if (this._connected_nodes.has(new_node_id)) {
            continue;
          }
          if (this._aware_of_nodes.has(new_node_id) || this._aware_of_nodes.size < this._aware_of_nodes_limit) {
            this._aware_of_nodes.set(new_node_id, +new Date);
            this['fire']('aware_of_nodes_count', this._aware_of_nodes.size);
          } else if (stale_aware_of_nodes.length) {
            stale_node_to_remove = pull_random_item_from_array(stale_aware_of_nodes);
            this._aware_of_nodes['delete'](stale_node_to_remove);
            this._aware_of_nodes.set(new_node_id, +new Date);
            this['fire']('aware_of_nodes_count', this._aware_of_nodes.size);
          } else {
            break;
          }
        }
      }
      /**
       * @param {!Uint8Array} for_node_id
       *
       * @return {!Array<!Uint8Array>}
       */,
      'get_aware_of_nodes': function(for_node_id){
        var nodes, aware_of_nodes, i$, _, node, candidates, to$, this$ = this;
        nodes = [];
        aware_of_nodes = Array.from(this._aware_of_nodes.keys());
        for (i$ = 0; i$ < 10; ++i$) {
          _ = i$;
          if (!aware_of_nodes.length) {
            break;
          }
          node = pull_random_item_from_array(aware_of_nodes);
          if (node) {
            nodes.push(node);
          }
        }
        if (nodes.length < 10) {
          candidates = ArraySet();
          this._peers.forEach(function(peer_peers, peer_id){
            if (!are_arrays_equal(for_node_id, peer_id)) {
              peer_peers.forEach(function(candidate){
                if (!this$._peers.has(candidate)) {
                  candidates.add(candidate);
                }
              });
            }
          });
          candidates = Array.from(candidates);
          for (i$ = 0, to$ = Math.min(5, 10 - nodes.length); i$ < to$; ++i$) {
            _ = i$;
            if (!candidates.length) {
              break;
            }
            node = pull_random_item_from_array(candidates);
            if (node) {
              nodes.push(node);
            }
          }
        }
        return nodes;
      }
      /**
       * @return {boolean}
       */,
      'more_aware_of_nodes_needed': function(){
        return Boolean(this._aware_of_nodes.size < this._aware_of_nodes_limit || this._get_stale_aware_of_nodes(true).length);
      }
      /**
       * @param {boolean=} early_exit Will return single node if present, used to check if stale nodes are present at all
       *
       * @return {!Array<!Uint8Array>}
       */,
      _get_stale_aware_of_nodes: function(early_exit){
        var stale_aware_of_nodes, stale_older_than, exited;
        early_exit == null && (early_exit = false);
        stale_aware_of_nodes = [];
        stale_older_than = +new Date - this._stale_aware_of_node_timeout * 1000;
        exited = false;
        this._aware_of_nodes.forEach(function(date, node_id){
          if (!exited && date < stale_older_than) {
            stale_aware_of_nodes.push(node_id);
            if (early_exit && !exited) {
              exited = true;
            }
          }
        });
        return stale_aware_of_nodes;
      }
      /**
       * Get some random nodes suitable for constructing routing path through them or for acting as introduction nodes
       *
       * @param {number}					number_of_nodes
       * @param {!Array<!Uint8Array>=}	exclude_nodes
       *
       * @return {Array<!Uint8Array>} `null` if there was not enough nodes
       */,
      'get_nodes_for_routing_path': function(number_of_nodes, exclude_nodes){
        var connected_node, ref$, intermediate_nodes;
        exclude_nodes == null && (exclude_nodes = []);
        exclude_nodes = Array.from(this._used_first_nodes.values()).concat(exclude_nodes);
        connected_node = (ref$ = this._get_random_connected_nodes(1, exclude_nodes)) != null ? ref$[0] : void 8;
        if (!connected_node) {
          return null;
        }
        intermediate_nodes = this._get_random_aware_of_nodes(number_of_nodes - 1, exclude_nodes.concat([connected_node]));
        if (!intermediate_nodes) {
          return null;
        }
        this._used_first_nodes.add(connected_node);
        return [connected_node].concat(intermediate_nodes);
      }
      /**
       * Get some random nodes from those that current node is aware of
       *
       * @param {number}					number_of_nodes
       * @param {!Array<!Uint8Array>=}	exclude_nodes
       *
       * @return {Array<!Uint8Array>} `null` if there was not enough nodes
       */,
      _get_random_aware_of_nodes: function(number_of_nodes, exclude_nodes){
        var aware_of_nodes, exclude_nodes_set, i$, i, results$ = [];
        if (this._aware_of_nodes.size < number_of_nodes) {
          return null;
        }
        aware_of_nodes = Array.from(this._aware_of_nodes.keys());
        if (exclude_nodes) {
          exclude_nodes_set = ArraySet(exclude_nodes);
          aware_of_nodes = aware_of_nodes.filter(function(node){
            return !exclude_nodes_set.has(node);
          });
        }
        if (aware_of_nodes.length < number_of_nodes) {
          return null;
        }
        for (i$ = 0; i$ < number_of_nodes; ++i$) {
          i = i$;
          results$.push(pull_random_item_from_array(aware_of_nodes));
        }
        return results$;
      }
      /**
       * @param {!Uint8Array} node_id
       */,
      'del_first_node_in_routing_path': function(node_id){
        this._used_first_nodes['delete'](node_id);
      },
      'destroy': function(){
        if (this._destroyed) {
          return;
        }
        this._destroyed = true;
        clearInterval(this._cleanup_interval);
      }
    };
    Manager.prototype = Object.assign(Object.create(asyncEventer.prototype), Manager.prototype);
    Object.defineProperty(Manager.prototype, 'constructor', {
      value: Manager
    });
    return Manager;
  }
  if (typeof define === 'function' && define['amd']) {
    define(['@detox/utils', 'async-eventer'], Wrapper);
  } else if (typeof exports === 'object') {
    module.exports = Wrapper(require('@detox/utils'), require('async-eventer'));
  } else {
    this['detox_nodes_manager'] = Wrapper(this['detox_utils'], this['async_eventer']);
  }
}).call(this);
